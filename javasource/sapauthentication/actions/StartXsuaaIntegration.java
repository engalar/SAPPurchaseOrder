// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package sapauthentication.actions;

import static sapauthentication.proxies.microflows.Microflows.addRole;
import static sapauthentication.proxies.microflows.Microflows.createUser;
import static sapauthentication.proxies.microflows.Microflows.resetRoles;
import static sapauthentication.proxies.microflows.Microflows.storeAccessToken;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.KeyFactory;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.text.MessageFormat;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.fluent.Form;
import org.apache.http.client.fluent.Request;
import org.apache.http.util.EntityUtils;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.externalinterface.connector.RequestHandler;
import com.mendix.logging.ILogNode;
import com.mendix.m2ee.api.IMxRuntimeRequest;
import com.mendix.m2ee.api.IMxRuntimeResponse;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.ISession;
import com.mendix.systemwideinterfaces.core.IUser;
import com.mendix.thirdparty.org.json.JSONObject;
import com.mendix.webui.CustomJavaAction;
import sapauthentication.proxies.SapUser;
import sapauthentication.proxies.constants.Constants;
import sapauthentication.xsuaa.XsuaaBindingSettings;
import sapauthentication.xsuaa.XsuaaIdentity;

public class StartXsuaaIntegration extends CustomJavaAction<java.lang.Boolean>
{
	public StartXsuaaIntegration(IContext context)
	{
		super(context);
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
        LOGGER.info("Starting XSA-UAA SSO integration ...");

        if (!XsuaaBindingSettings.isXsaUaaEnvironment()) {
            LOGGER.warn("Not running in SAP environment. Go to the built-in authentication mechanism");
            return true;
        }

        final XsuaaBindingSettings settings = XsuaaBindingSettings.importSettingsFromEnvironment();

        Core.addRequestHandler("xsauaalogin/", new RequestHandler() {
            @Override
            protected void processRequest(final IMxRuntimeRequest request, final IMxRuntimeResponse response, final String path) throws Exception {

                LOGGER.debug("Incoming XSA-UAA login request ...");

                if (!isGetRequest(request)) {
                    response.setStatus(HttpStatus.SC_METHOD_NOT_ALLOWED);
                } else {
                    final String authorizationLocation = settings.getUrl() //
                            + "/oauth/authorize?response_type=code&redirect_uri=" + settings.getUrlEncodedRedirectUri() //
                            + "&client_id=" + settings.getClientId();

                    LOGGER.debug("Redirecting user to XSA-UAA for authentication ... ");

                    redirectUser(response, authorizationLocation);
                }
            }
        });

        Core.addRequestHandler(XsuaaBindingSettings.AUTHENTICATION_CALLBACK_PATH , new RequestHandler() {
            @Override
            protected void processRequest(final IMxRuntimeRequest request, final IMxRuntimeResponse response, final String path) throws Exception {

                LOGGER.debug("Incoming callback request from XSUAA: " + path);

                if (!isGetRequest(request)) {
                    response.setStatus(HttpStatus.SC_METHOD_NOT_ALLOWED);
                } else {
                    final String code = retrieveCodeQueryParameterFromRequest(request);
                    final String accessToken = retrieveAuthorityAccessToken(settings, code);
                    final Map<String, Claim> claims = retrieveClaimsFromAuthorityAccessToken(settings, accessToken);

                    final XsuaaIdentity identity = new XsuaaIdentity(claims, settings.getXsAppName());
                    LOGGER.debug(identity.toString());

                    final IContext context = Core.createSystemContext();

                    context.startTransaction();
                    createOrUpdateUser(accessToken, identity.getUsername(), identity.getFullname(), identity.getEmail(), identity.getMendixRoles(), context);
                    context.endTransaction();

                    context.startTransaction();
                    login(context, request, response, identity, accessToken);
                    LOGGER.debug("Redirecting user to application home after authentication ... ");
                    redirectUser(response, "/");
                    context.endTransaction();
                }
            }
        });

        return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "StartXsuaaIntegration";
	}

	// BEGIN EXTRA CODE

    private static final String SAP_AUTHENTICATION_DEFAULT_ROLE_CONSTANT = "SapAuthentication.DefaultRole";
    private static final String SAP_AUTHENTICATION_DEFAULT_ROLE = (String) Core.getConfiguration().getConstantValue(SAP_AUTHENTICATION_DEFAULT_ROLE_CONSTANT);

    private static final String SESSION_ID_COOKIE_NAME = Core.getConfiguration().getSessionIdCookieName();
	private static final ILogNode LOGGER = Core.getLogger(Constants.getLogNode());

    private static final String KEY_FORMAT_BEGIN_MARK = "-----BEGIN PUBLIC KEY-----";
    private static final String KEY_FORMAT_END_MARK = "-----END PUBLIC KEY-----";

    private static String retrieveCodeQueryParameterFromRequest(final IMxRuntimeRequest mxRequest) {

        LOGGER.debug("Retrieving code from request parameter <START>");

        final String code = mxRequest.getParameter("code");

        if (code == null) {
            throw new RuntimeException("No 'code' parameter");
        }
        
        LOGGER.debug("Retrieving code from request parameter <END> code ["+code+"]");

        return code;
    }

    private static String retrieveAuthorityAccessToken(final XsuaaBindingSettings settings, final String code) throws IOException {

        LOGGER.debug("Retrieving access token from authority <START>");

        final String uri = settings.getUrl() + "/oauth/token";
        LOGGER.debug("URL ["+uri+"]");
        final String encodedCredentials = new String( //
                Base64.getEncoder().encode((settings.getClientId() + ':' + settings.getClientSecret()).getBytes()));

        final HttpResponse response = Request.Post(uri).addHeader("Authentication", "Basic " + encodedCredentials) //
                .bodyForm(//
                        Form.form()//
                                .add("grant_type", "authorization_code")//
                                .add("client_id", settings.getClientId())//
                                .add("client_secret", settings.getClientSecret())//
                                .add("code", code)//
                                .add("redirect_uri", settings.getRedirectUri())//
                                .build()//
                ).execute().returnResponse();

        final String responseEntity = EntityUtils.toString(response.getEntity());
        
        LOGGER.debug("Raw Response ["+responseEntity+"]");

        if (!(response.getStatusLine().getStatusCode() == HttpStatus.SC_OK)) {
            throw new RuntimeException("XSA-UAA did not respond with 200: " + response.getStatusLine());
        }

        final JSONObject responseObject = new JSONObject(responseEntity);
        
        LOGGER.debug("Retrieving access token from authority <END>");
        
        return responseObject.getString("access_token");
    }

	private static Map<String, Claim> retrieveClaimsFromAuthorityAccessToken(final XsuaaBindingSettings settings, final String accessToken) throws RuntimeException {

        LOGGER.debug("Retriving the claims for Access Token <START>");

        try {
			String verificationKey = settings.getVerificationKey();
			final DecodedJWT decodedjwt = JWT.decode(accessToken);
			final String verificationAlgorithm = decodedjwt.getAlgorithm();
			
			final JWTVerifier verifier = getVerifier(verificationAlgorithm, verificationKey);
			
			final DecodedJWT jwt = verifier.verify(accessToken);
			
			LOGGER.debug("Retriving the claims for Access Token <END>");
			return jwt.getClaims();
			
		} catch(JWTVerificationException e1) {
			throw new RuntimeException("Failed verifing the signature of the access token", e1);
		}
    }
	
	public static JWTVerifier getVerifier(String algoritm, String verificationKey) {
		
		Algorithm algorithm= null;
		switch(algoritm) {
			// RSA
			case "RS256":
				algorithm = Algorithm.RSA256(getRSAKeyFactory(verificationKey), null);
			    break;
			case "RS384":
				algorithm = Algorithm.RSA384(getRSAKeyFactory(verificationKey), null);
				break;
			case "RS512":
				algorithm = Algorithm.RSA512(getRSAKeyFactory(verificationKey), null);
				break;	
			// ECDSA
			case "ES256":	
				algorithm = Algorithm.ECDSA256(getECDSAKeyFactory(verificationKey), null);
				break;
			case "ES384":	
				algorithm = Algorithm.ECDSA384(getECDSAKeyFactory(verificationKey), null);
				break;
			case "ES512":	
				algorithm = Algorithm.ECDSA512(getECDSAKeyFactory(verificationKey), null);
				break;
			// HMAC
			case "HS256":	
				try {
					algorithm = Algorithm.HMAC256(verificationKey);
				} catch (IllegalArgumentException | UnsupportedEncodingException e) {
					throw new RuntimeException(e);
				}
				break;
			case "HS384":	
				try {
					algorithm = Algorithm.HMAC384(verificationKey);
				} catch (IllegalArgumentException | UnsupportedEncodingException e) {
					throw new RuntimeException(e);
				}
				break;
			case "HS512":	
				try {
					algorithm = Algorithm.HMAC512(verificationKey);
				} catch (IllegalArgumentException | UnsupportedEncodingException e) {
					throw new RuntimeException(e);
				}
				break;
		    default:
		    	throw new RuntimeException(MessageFormat.format("The algorithm $s is not supported", algorithm));		
		}
		
		return JWT.require(algorithm).build(); 
	}

	public static RSAPublicKey getRSAKeyFactory(String verificationKey) {
		verificationKey = verificationKey.replace(KEY_FORMAT_BEGIN_MARK, "");
		verificationKey = verificationKey.replace(KEY_FORMAT_END_MARK, "");
	
		final byte[] keyBytes = Base64.getDecoder().decode(verificationKey);
		final X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
		
		try {
			final KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			return (RSAPublicKey) keyFactory.generatePublic(spec);
		}catch(Exception e) {
			throw new RuntimeException(e);
		}
	}
	
	public static ECPublicKey getECDSAKeyFactory(String verificationKey) {
		verificationKey = verificationKey.replace(KEY_FORMAT_BEGIN_MARK, "");
		verificationKey = verificationKey.replace(KEY_FORMAT_END_MARK, "");
	
		final byte[] keyBytes = Base64.getDecoder().decode(verificationKey);
		final X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
		
		try {
			final KeyFactory keyFactory = KeyFactory.getInstance("EC");
			return (ECPublicKey) keyFactory.generatePublic(spec);
		}catch(Exception e) {
			throw new RuntimeException(e);
		}
	}

    private static void createOrUpdateUser(final String accessToken, final String username, final String fullname, final String email, final List<String> roles, final IContext context) throws CoreException {

        LOGGER.debug("Creating or updating an user <START>");

        final IUser existingUser = Core.getUser(context, username);

        final SapUser user;
        if (existingUser == null) {
            LOGGER.info("User does not yet exist - creating account and logging in ...");
            user = createUser(context, email, fullname, username);
        } else {
            LOGGER.info("User exists - resetting roles and logging in ...");
            user = SapUser.initialize(context, existingUser.getMendixObject());
        }

        resetRoles(context, user);
        if(roles.size() > 0) {        	
        	for (final String role : roles) {
        		addRole(context, role, user);
        	}
        }
        else {
        	LOGGER.debug("No Roles present in scope for app, Setting default role ["+SAP_AUTHENTICATION_DEFAULT_ROLE+"]");
        	addRole(context, SAP_AUTHENTICATION_DEFAULT_ROLE, user);
        }

        storeAccessToken(context, accessToken, user);
        
        LOGGER.debug("Creating or updating an user <END>");
    }

    private static void login(final IContext context, final IMxRuntimeRequest request, final IMxRuntimeResponse response, final XsuaaIdentity identity, final String accessToken) throws CoreException {

        LOGGER.info("Initializing session for user " + identity.getUsername() + " <START>");

        final IUser federatedUser = Core.getUser(context, identity.getUsername());

        final String oldSessionId = request.getCookie(SESSION_ID_COOKIE_NAME);
        final ISession session = Core.initializeSession(federatedUser, oldSessionId);

        response.addCookie(SESSION_ID_COOKIE_NAME, session.getId().toString(), "/", "", -1, true);
        response.addCookie("XASID", "0." + Core.getXASId(), "/", "", -1, true);
        response.addCookie("access_token", accessToken, "/", "", -1, true);
        
        LOGGER.info("Initializing session for user " + identity.getUsername() + " <END>");
    }
    
    private static void redirectUser(final IMxRuntimeResponse response, final String redirectUri) {
        LOGGER.info("Redirecting user to: " + redirectUri);

        response.setStatus(HttpStatus.SC_MOVED_TEMPORARILY);
        response.addHeader("Location", redirectUri);
    }

    private static boolean isGetRequest(final IMxRuntimeRequest request) {
        return "GET".equals(request.getHttpServletRequest().getMethod());
    }
	// END EXTRA CODE
}
